# HTTP 웹 기본 지식

[TOC]



## 1. 인터넷 네트워크

### 1.1. 인터넷 통신

- 인터넷에서 컴퓨터 두 대는 **클라이언트와 서버 간의 요청(Hello, world!) 및 응답(OK)을 통해 통신**합니다.
- 이 통신은 **복잡한 인터넷 망과 노드(Node)**를 거쳐 이루어집니다.

### 1.2. IP (Internet Protocol)

- 역할

  :

  - **지정한 IP 주소(IP Address)에 데이터를 전달**합니다.
  - **패킷(Packet)이라는 통신 단위로 데이터를 전달**합니다.

- IP 패킷 정보

  :

  - **출발지 IP**: 패킷을 보낸 컴퓨터의 IP 주소.
  - **목적지 IP**: 패킷이 도달해야 할 컴퓨터의 IP 주소.
  - 기타 필요한 정보 및 **전송 데이터** (예: "Hello, world!" 또는 "OK").

- IP 프로토콜의 한계

  :

  - **비연결성 (Connectionless)**: 패킷을 받을 대상이 없거나 서비스 불능 상태여도 일단 패킷을 전송합니다.
  - **비신뢰성 (Unreliable)**: 중간에 패킷이 사라지거나, 패킷이 순서대로 도착하지 않을 수 있습니다.
  - **프로그램 구분 불가**: 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 때, IP만으로는 특정 프로그램을 구분하여 데이터를 전달할 수 없습니다.

### 1.3. TCP, UDP

- 인터넷 통신은 여러 계층의 프로토콜 스택을 통해 이루어지며, **TCP와 UDP는 '전송 계층(Transport Layer)'에 위치**합니다. IP는 '인터넷 계층(Internet Layer)'에 속합니다.
- **TCP/IP 패킷 정보**: IP 패킷이 담는 정보(출발지 IP, 목적지 IP) 외에 **출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등**이 추가됩니다.
- **TCP (Transmission Control Protocol)**
  - **연결지향 (Connection-oriented)**: 데이터를 주고받기 전에 **TCP 3-way handshake** (SYN -> SYN+ACK -> ACK)를 통해 가상 연결을 수립합니다.
  - **데이터 전달 보증**: 전송된 데이터가 잘 도착했음을 확인하고, 받지 못하면 재전송합니다.
  - **순서 보장**: 패킷이 순서대로 도착하도록 보장하며, 순서가 뒤바뀌면 재정렬하거나 재전송을 요청합니다.
  - **신뢰할 수 있는 프로토콜**: 위와 같은 특징들 덕분에 IP의 비신뢰성 한계를 보완하여 신뢰성 있는 데이터 전송을 가능하게 합니다.
  - 현재 **대부분의 인터넷 애플리케이션은 TCP를 사용**합니다. (예: HTTP/1.1, HTTP/2는 TCP 기반).
- **UDP (User Datagram Protocol)**
  - **'하얀 도화지에 비유'**될 만큼 기능이 거의 없습니다.
  - **비연결성 (Connectionless)**: TCP처럼 3-way handshake 과정이 없습니다.
  - **데이터 전달 보증 X**: 데이터가 제대로 도착했는지 확인하지 않으며, 손실되어도 재전송하지 않습니다.
  - **순서 보장 X**: 패킷의 순서가 뒤바뀌어 도착해도 보장하거나 재정렬하지 않습니다.
  - **단순하고 빠름**: 기능이 적은 만큼 TCP보다 훨씬 빠르고 오버헤드가 적습니다.
  - **IP와 거의 유사**: IP에 **PORT와 체크섬(checksum) 정도만 추가**된 형태입니다.
  - 신뢰성이나 순서 보장이 필요한 경우, **애플리케이션에서 추가 작업이 필요**합니다. (예: HTTP/3는 UDP 기반).

### 1.4. PORT

- 같은 IP 내에서 여러 애플리케이션(프로세스)을 구분

  하는 데 사용됩니다.

  - 예를 들어, 같은 서버 IP에서 웹 서버(80번 포트), 게임 서버(8090번 포트), 화상 통화(21000번 포트)가 동시에 실행될 수 있습니다.

- **할당 가능 범위**: 0 ~ 65535.

- **0 ~ 1023번 포트는 '잘 알려진 포트(Well-known Port)'**로, 특정 서비스에 할당되어 있으므로 가급적 사용하지 않는 것이 좋습니다.

  - 예: FTP(20, 21), TELNET(23), **HTTP(80)**, **HTTPS(443)**.

### 1.5. DNS (Domain Name System)

- **'전화번호부'**와 같은 역할을 합니다.
- **도메인 명(예: google.com)을 IP 주소(예: 200.200.200.2)로 변환**해 줍니다.
- 사용자가 IP 주소를 직접 기억하기 어렵고, 서버의 IP 주소가 변경될 수 있기 때문에 필요합니다.

## 2. URI와 웹 브라우저 요청 흐름

### 2.1. URI (Uniform Resource Identifier)

- **Uniform (통일된 방식)**: 리소스를 식별하는 통일된 방식.
- **Resource (자원)**: URI로 식별할 수 있는 모든 것 (제한 없음).
- **Identifier (식별자)**: 다른 항목과 구분하는 데 필요한 정보.
- URI는 **URL (Uniform Resource Locator)**과 **URN (Uniform Resource Name)**으로 추가 분류될 수 있습니다.
  - **URL**: 리소스가 있는 **위치(Locator)**를 지정합니다.
  - **URN**: 리소스에 **이름(Name)**을 부여합니다 (위치는 변할 수 있지만 이름은 변하지 않음).
  - 현재 URN 이름만으로 실제 리소스를 찾을 수 있는 방법은 보편화되어 있지 않습니다.
  - **향후 'URI'라는 용어는 'URL'과 같은 의미로 사용될 것입니다**.

### 2.2. URL 분석

- URL의 전체 문법은 `scheme://[userinfo@]host[:port][/path][?query][#fragment]`로 구성됩니다.

  - scheme (프로토콜)

    : 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙입니다.

    - 주로 프로토콜이 사용됩니다 (예: `http`, `https`, `ftp` 등).
    - `http`는 80 포트를, `https`는 443 포트를 주로 사용하며, 포트는 생략 가능합니다.
    - `https`는 `http`에 보안이 추가된 것입니다 (HTTP Secure).

  - **userinfo**: URL에 사용자 정보(인증)를 포함하는 부분이지만, **거의 사용되지 않습니다**.

  - **host (호스트명)**: 도메인명 또는 IP 주소를 직접 사용할 수 있습니다.

  - **port (포트)**: 접속 포트를 의미하며, 일반적으로 생략 시 `http`는 80, `https`는 443이 사용됩니다.

  - **path (패스)**: 리소스 경로로, 계층적 구조를 가집니다 (예: `/home/file1.jpg`).

  - **query (쿼리 파라미터)**: `key=value` 형태이며, `?`로 시작하고 `&`로 추가할 수 있습니다. 웹 서버에 제공하는 파라미터로 사용됩니다.

  - **fragment (프래그먼트)**: HTML 내부의 북마크 등에 사용되며, **서버에 전송하는 정보가 아닙니다**.

### 2.3. 웹 브라우저 요청 흐름

1. **DNS 조회**: 웹 브라우저가 입력된 도메인명(예: `www.google.com`)을 DNS 서버에 질의하여 해당 서버의 **IP 주소(예: 200.200.200.2)를 조회**합니다.
2. **HTTP 요청 메시지 생성**: 웹 브라우저가 `GET /search?q=hello&hl=ko HTTP/1.1 Host: www.google.com`와 같은 **HTTP 요청 메시지를 생성**합니다.
3. **TCP/IP 패킷 생성 및 전송**: 생성된 HTTP 메시지는 **SOCKET 라이브러리를 통해 전달**되어, **출발지 IP, PORT, 목적지 IP, PORT 등의 정보가 포함된 TCP/IP 패킷으로 변환**됩니다. 이 패킷은 인터넷 망을 통해 구글 서버로 전달됩니다.
4. **HTTP 응답 메시지 생성 및 전송**: 구글 서버는 요청을 처리한 후, **HTTP 응답 메시지(예: HTML)를 생성**하고, 이를 TCP/IP 패킷으로 변환하여 웹 브라우저로 전송합니다.
5. **웹 브라우저 HTML 렌더링**: 웹 브라우저는 수신된 HTTP 응답 메시지를 해석하여 화면에 HTML을 렌더링합니다.

## 3. HTTP (HyperText Transfer Protocol)

### 3.1. 모든 것이 HTTP

- HTTP는 **메시지에 모든 것을 전송**합니다.
- **HTML, TEXT, 이미지, 음성, 영상, 파일 등 거의 모든 형태의 데이터를 전송**할 수 있습니다.
- API 통신을 위한 **JSON, XML** 등의 데이터도 전송합니다.
- **서버 간 데이터를 주고받을 때도 대부분 HTTP를 사용**하며, 현재는 'HTTP 시대'라고 불릴 정도로 널리 사용됩니다.

### 3.2. HTTP 역사

- **HTTP/0.9 (1991년)**: GET 메서드만 지원했고 HTTP 헤더가 없었습니다.

- **HTTP/1.0 (1996년)**: 메서드와 헤더가 추가되었습니다.

- HTTP/1.1 (1997년)

  : 

  현재 가장 많이 사용되고 있으며, 우리에게 가장 중요한 버전

  입니다.

  - TCP를 기반으로 합니다.

- **HTTP/2 (2015년)**: 성능 개선을 목표로 등장했으며, 여전히 TCP를 기반으로 합니다.

- **HTTP/3 (진행 중)**: **TCP 대신 UDP를 사용하여 성능 개선을 시도**하고 있습니다.

### 3.3. HTTP 특징

- **클라이언트-서버 구조**: 클라이언트가 요청을 보내고 서버가 응답하는 구조입니다.

- 무상태 프로토콜 (Stateless)

  - **서버가 클라이언트의 상태를 보존하지 않습니다**. 즉, 서버는 과거 요청의 정보를 기억하지 못합니다.

  - 장점

    :

    - **서버 확장성이 매우 높습니다 (스케일 아웃에 유리)**. 갑자기 클라이언트 요청이 증가해도 아무 서버나 호출하여 응답할 수 있기 때문에 서버를 무한히 증설할 수 있습니다.

  - **단점**: 클라이언트가 모든 요청에 필요한 데이터를 서버에 전송해야 합니다.

  - **실무 한계**: 로그인과 같이 상태 유지가 필요한 경우에는 브라우저 쿠키와 서버 세션 등을 사용하여 상태를 유지합니다. 무상태는 최소한으로만 사용해야 합니다.

- 비연결성 (Connectionless)

  - HTTP는 기본적으로 **연결을 유지하지 않는 모델**입니다. 클라이언트와 서버가 요청과 응답을 주고받으면 TCP/IP 연결이 끊어집니다.
  - **장점**: 서버 자원을 매우 효율적으로 사용할 수 있습니다. (예: 웹 브라우저는 계속 검색 버튼을 누르지 않으므로, 수천 명이 서비스를 사용해도 실제 동시 처리 요청은 적습니다).
  - **한계와 극복**: 요청마다 TCP/IP 연결을 새로 맺는 과정(3-way handshake)에 시간이 추가되고, 페이지 로딩 시 수많은 자원을 따로 다운로드해야 하는 비효율이 있었습니다. 이를 **HTTP 지속 연결(Persistent Connections)**로 해결하여 한 번 연결 후 여러 요청을 처리할 수 있게 되었습니다. HTTP/2, HTTP/3에서는 더 많은 최적화가 이루어졌습니다.

- **HTTP 메시지**: 요청과 응답 메시지 구조를 통해 통신합니다.

- **단순함, 확장 가능**: HTTP는 단순하지만 확장성이 뛰어나 성공적인 표준 기술입니다.

### 3.4. HTTP 메시지 구조

HTTP 메시지는 크게 **시작 라인(start-line), 헤더(header), 공백 라인(empty line), 메시지 바디(message body)**로 구성됩니다.

- 시작 라인 (start-line)

  - 요청 메시지

    : 

    ```
    method SP request-target SP HTTP-version CRLF
    ```

     형식입니다.

    - **HTTP 메서드**: 서버가 수행해야 할 동작을 지정합니다 (예: **GET, POST** 등).
    - **요청 대상**: 리소스의 절대 경로 및 쿼리를 포함합니다 (예: `/search?q=hello&hl=ko`).
    - **HTTP Version**: HTTP 프로토콜 버전을 나타냅니다 (예: HTTP/1.1).

  - 응답 메시지

    : 

    ```
    HTTP-version SP status-code SP reason-phrase CRLF
    ```

     형식입니다.

    - **HTTP 버전**: HTTP 프로토콜 버전을 나타냅니다.
    - **HTTP 상태 코드**: 요청의 성공, 실패 여부 등 처리 상태를 나타내는 숫자 코드입니다 (예: **200: 성공, 400: 클라이언트 요청 오류, 500: 서버 내부 오류**).
    - **이유 문구**: 사람이 이해할 수 있는 짧은 상태 코드 설명 글입니다 (예: OK, Bad Request).

- 헤더 (header)

  - `field-name ":" OWS field-value OWS` (OWS: 띄어쓰기 허용) 형식이며, 필드 이름은 대소문자를 구분하지 않습니다.
  - **HTTP 전송에 필요한 모든 부가 정보**를 담습니다. (예: 메시지 바디의 내용, 크기, 압축 방식, 인증 정보, 요청 클라이언트/서버 정보, 캐시 관리 정보 등).
  - 표준 헤더가 매우 많으며, 필요시 임의의 헤더를 추가할 수 있습니다.
  - 과거 'Entity 헤더'로 불리던 부분이 RFC7230+ 표준에서는 **'표현(Representation) 헤더'**로 명칭이 변경되었습니다.

- **공백 라인 (empty line)**

- 메시지 바디 (message body)

  - **실제 전송할 데이터(페이로드)**를 포함합니다.
  - HTML 문서, 이미지, 영상, JSON 등 바이트로 표현할 수 있는 모든 데이터를 전송할 수 있습니다.
  - '표현 헤더'가 이 표현 데이터를 해석할 수 있는 정보를 제공합니다 (예: `Content-Type`, `Content-Encoding`, `Content-Language`, `Content-Length`).

## 4. HTTP 메서드

### 4.1. 주요 메서드

- GET

  :

  - **리소스 조회**에 사용됩니다.
  - 서버에 전달하고 싶은 데이터는 주로 **쿼리 파라미터(query parameter, query string)를 통해 전달**합니다. 메시지 바디를 사용해서 데이터를 전달할 수도 있지만, 지원하지 않는 곳이 많아 권장하지 않습니다.
  - **주의**: GET은 조회에만 사용해야 하며, 리소스 변경이 발생하는 곳에는 사용하면 안 됩니다.

- POST

  :

  - **요청 데이터 처리**에 사용되며, 주로 **신규 리소스 등록**에 사용됩니다.
  - **메시지 바디를 통해 서버로 요청 데이터를 전달**합니다.
  - 전달된 데이터를 처리하는 모든 기능을 수행할 수 있습니다.
  - 예시: HTML 양식 데이터 처리(회원 가입, 주문), 게시판/블로그 메시지 게시, 서버가 아직 식별하지 않은 **새 리소스 생성** (신규 주문), 기존 자원에 데이터 추가 (한 문서 끝에 내용 추가).
  - **클라이언트는 등록될 리소스의 URI를 모릅니다**. 서버가 새로 등록된 리소스의 URI를 생성하여 응답의 `Location` 헤더 필드로 알려줍니다.
  - 단순히 값을 변경하는 것을 넘어 **프로세스를 처리해야 하는 경우** (예: 주문 결제완료 -> 배달시작)나 다른 메서드로 처리하기 **애매한 경우** (예: JSON으로 조회 데이터를 넘겨야 하는데 GET 사용이 어려운 경우)에도 사용됩니다.

- PUT

  :

  - **리소스를 대체(overwrite)합니다**. 리소스가 있으면 대체하고, 없으면 생성합니다.
  - **클라이언트가 리소스의 위치(URI)를 알고 직접 지정**합니다.
  - **주의**: 리소스를 완전히 대체하므로, 요청 바디에 포함되지 않은 필드는 삭제될 수 있습니다.

- PATCH

  :

  - **리소스의 부분 변경**에 사용됩니다. (PUT이 전체를 대체하는 것과 대조됨).

- DELETE

  :

  - **리소스를 제거**하는 데 사용됩니다.

### 4.2. 기타 메서드

- **HEAD**: `GET`과 동일하지만, 메시지 부분(바디)을 제외하고 상태 줄과 헤더만 반환합니다.
- **OPTIONS**: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명합니다. 주로 CORS(Cross-Origin Resource Sharing)에서 사용됩니다.
- **CONNECT**: 대상 리소스로 식별되는 서버에 대한 터널을 설정합니다.
- **TRACE**: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행합니다.

### 4.3. HTTP 메서드의 속성

- 안전 (Safe Methods)

  :

  - **호출해도 리소스를 변경하지 않습니다**.
  - `GET` 메서드가 대표적입니다. (로그가 쌓여 장애가 발생하더라도, 리소스 자체를 변경하지 않는다는 의미입니다).

- 멱등 (Idempotent Methods)

  :

  - **한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같습니다** (`f(f(x)) = f(x)`).
  - **멱등 메서드**: `GET` (조회 결과 동일), `PUT` (대체 결과 동일), `DELETE` (삭제 결과 동일).
  - **`POST`는 멱등이 아닙니다!** 두 번 호출하면 같은 결제가 중복해서 발생할 수 있습니다.
  - **활용**: 서버가 TIMEOUT 등으로 정상 응답을 못 주었을 때 클라이언트가 같은 요청을 다시 해도 되는지 판단하는 근거로 사용됩니다 (자동 복구 메커니즘).
  - 주의: 멱등은 외부 요인으로 중간에 리소스가 변경되는 것까지는 고려하지 않습니다.

- 캐시가능 (Cacheable Methods)

  :

  - **응답 결과 리소스를 캐시해서 사용해도 되는가**를 나타냅니다.
  - `GET`, `HEAD`가 주로 캐시로 사용됩니다.
  - `POST`, `PATCH`는 본문 내용까지 캐시 키로 고려해야 하므로 캐시 구현이 쉽지 않아 잘 사용되지 않습니다.

### 4.4. 클라이언트에서 서버로 데이터 전송

데이터 전달 방식은 크게 두 가지입니다.

- 쿼리 파라미터를 통한 데이터 전송

  :

  - 주로 **GET** 메서드와 함께 사용됩니다.
  - 정렬, 필터(검색어) 등 **조회 조건**을 전달하는 데 적합합니다.

- 메시지 바디를 통한 데이터 전송

  :

  - 주로 **POST, PUT, PATCH** 메서드와 함께 사용됩니다.
  - 회원 가입, 상품 주문, 리소스 등록 및 변경 등 **데이터를 생성하거나 변경**하는 데 사용됩니다.

**데이터 전송의 4가지 상황**:

1. 정적 데이터 조회

   :

   - 이미지, 정적 텍스트 문서 등.
   - **GET** 메서드를 사용하며, 일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회합니다.

2. 동적 데이터 조회

   :

   - 주로 검색, 게시판 목록에서 정렬, 필터(검색어) 등.
   - **GET** 메서드를 사용하며, **쿼리 파라미터**를 사용하여 조회 조건을 전달합니다.

3. HTML Form을 통한 데이터 전송

   :

   - 회원 가입, 상품 주문, 데이터 변경 등.

   - `<form>` 태그의 `action` 및 `method` 속성을 통해 데이터를 전송합니다.

   - `method="post"`

     :

     - `POST /save HTTP/1.1 Content-Type: application/x-www-form-urlencoded` 형식으로 요청 메시지를 생성합니다.
     - 폼의 내용은 메시지 바디를 통해 `key=value` 형태(쿼리 파라미터 형식)로 전송되며, 전송 데이터는 URL 인코딩 처리됩니다 (예: `username=kim&age=20`).
     - 파일 업로드 시에는 `enctype="multipart/form-data"`를 사용하며, 여러 종류의 파일과 폼 내용을 함께 전송할 수 있습니다.

   - `method="get"`

     :

     - `GET /save?username=kim&age=20 HTTP/1.1` 형식으로 요청 메시지를 생성합니다.
     - **주의**: `GET`은 조회에만 사용해야 하므로, **리소스 변경이 발생하는 곳에 사용하면 안 됩니다**.

   - HTML Form 전송은 기본적으로 **GET과 POST만 지원**합니다.

4. HTTP API를 통한 데이터 전송

   :

   - 서버 간 통신, 앱 클라이언트(아이폰, 안드로이드), 웹 클라이언트(AJAX, React, Vue.js 등) 통신에 사용됩니다.
   - **POST, PUT, PATCH**는 주로 **메시지 바디를 통해 데이터 전송**합니다.
   - **GET**은 **쿼리 파라미터로 데이터 전달**하여 조회에 사용됩니다.
   - `Content-Type: application/json`을 주로 사용하며, 사실상 표준입니다.

### 4.5. HTTP API 설계 예시

- HTTP API - 컬렉션(Collection)

  :

  - **서버가 관리하는 리소스 디렉토리**를 의미합니다 (예: `/members`).
  - **서버가 리소스의 URI를 생성하고 관리**합니다.
  - 주로 **POST 기반 등록** 방식을 사용합니다. 클라이언트는 등록될 리소스의 URI를 모르고, 서버가 `Location` 헤더를 통해 새로 생성된 URI를 알려줍니다 (예: `POST /members` -> `Location: /members/100`).

- HTTP API - 스토어(Store)

  :

  - **클라이언트가 관리하는 자원 저장소**를 의미합니다 (예: `/files`).
  - **클라이언트가 리소스의 URI를 알고 직접 지정하고 관리**합니다.
  - 주로 **PUT 기반 등록** 방식을 사용합니다 (예: `PUT /files/star.jpg`).

- HTML FORM 사용

  :

  - **GET, POST만 지원**하는 제약이 있습니다.
  - 이러한 제약을 해결하기 위해 **'컨트롤 URI'** 개념을 사용합니다.
  - **컨트롤 URI**: 문서, 컬렉션, 스토어만으로는 해결하기 어려운 추가 프로세스 실행을 위해 **동사를 직접 사용한 리소스 경로**입니다 (예: `/members/{id}/delete`, `/members/new`, `/members/{id}/edit`). HTTP 메서드로 해결하기 애매한 경우에도 사용됩니다.

## 5. HTTP 상태코드

### 5.1. 개요

- **클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능**입니다.
- 클라이언트가 인식할 수 없는 상태 코드를 서버가 반환할 경우, 클라이언트는 해당 코드를 **상위 상태 코드(예: 299는 2xx, 451은 4xx, 599는 5xx)로 해석하여 처리**합니다. 이는 미래에 새로운 상태 코드가 추가되어도 클라이언트 변경 없이 동작할 수 있도록 합니다.

### 5.2. 분류

- **1xx (Informational)**: 요청이 수신되어 처리 중임을 나타내지만, **거의 사용되지 않습니다**.

- 2xx (Successful)

  : 클라이언트의 요청을 성공적으로 처리했음을 나타냅니다.

  - **200 OK**: 요청 성공.
  - **201 Created**: 요청이 성공하여 **새로운 리소스가 생성**되었음을 나타냅니다. 생성된 리소스는 응답의 **`Location` 헤더 필드로 식별**됩니다.
  - **202 Accepted**: 요청이 접수되었으나 처리가 완료되지 않았음을 나타냅니다. 배치 처리 등에서 사용될 수 있습니다.
  - **204 No Content**: 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 **본문에 보낼 데이터가 없음**을 나타냅니다. (예: 웹 문서 편집기에서 '저장' 버튼을 눌렀을 때, 화면 유지 및 성공 인식에 사용).

- 3xx (Redirection)

  : 요청을 완료하기 위해 사용자 에이전트(클라이언트)의 

  추가 조치(리다이렉트)가 필요함

  을 나타냅니다.

  - 웹 브라우저는 3xx 응답에 **`Location` 헤더가 있으면 해당 위치로 자동 이동(리다이렉트)**합니다.

  - 영구 리다이렉션

    : 리소스의 URI가 영구적으로 이동했음을 나타냅니다. 원래 URL은 더 이상 사용되지 않으며, 검색 엔진도 변경을 인지합니다.

    - **301 Moved Permanently**: 리다이렉트 시 **요청 메서드가 `GET`으로 변하고, 본문이 제거될 수 있습니다 (MAY)**.
    - **308 Permanent Redirect**: `301`과 기능은 같지만, 리다이렉트 시 **요청 메서드와 본문을 유지**합니다.

  - 일시적인 리다이렉션

    : 리소스의 URI가 일시적으로 변경되었음을 나타냅니다. 검색 엔진 등에서 URL을 변경하면 안 됩니다.

    - **302 Found**: 리다이렉트 시 **요청 메서드가 `GET`으로 변하고, 본문이 제거될 수 있습니다 (MAY)**. (`302` 스펙의 원래 의도는 메서드 유지였으나, 대부분의 웹 브라우저가 `GET`으로 변경해 버렸습니다).
    - **307 Temporary Redirect**: `302`와 기능은 같지만, 리다이렉트 시 **요청 메서드와 본문을 유지해야 합니다 (MUST NOT 변경)**.
    - **303 See Other**: `302`와 기능은 같지만, 리다이렉트 시 **요청 메서드가 `GET`으로 변경**됩니다.
    - **PRG (Post/Redirect/Get)**: `POST`로 주문 후 새로고침으로 인한 중복 주문을 방지하기 위해 사용됩니다. `POST` 요청 후 `302` 또는 `303` 응답과 함께 결과 화면의 `GET` URI로 리다이렉트하여, 새로고침 시에도 `GET`으로 조회하게 합니다.

  - 기타 리다이렉션

    :

    - **304 Not Modified**: **캐시 목적으로 사용**됩니다. 클라이언트에게 리소스가 수정되지 않았음을 알려주며, 클라이언트는 로컬 PC에 저장된 캐시를 재사용합니다 (캐시로 리다이렉트). `304` 응답에는 **메시지 바디를 포함하면 안 됩니다**. 조건부 `GET`, `HEAD` 요청 시 사용됩니다.

- 4xx (Client Error)

  : 

  클라이언트의 요청에 잘못된 문법 등이 있어서 서버가 요청을 수행할 수 없음

  을 나타냅니다.

  - 오류의 원인이 클라이언트에 있으므로, **똑같은 재시도는 실패**합니다.
  - **400 Bad Request**: 클라이언트가 잘못된 요청(구문, 메시지 오류 등)을 보내 서버가 요청을 처리할 수 없습니다.
  - **401 Unauthorized**: 클라이언트가 해당 리소스에 대한 **인증(Authentication)이 필요함**을 나타냅니다. (인증: 본인이 누구인지 확인, 예: 로그인). 응답에 `WWW-Authenticate` 헤더와 함께 인증 방법을 설명합니다.
  - **403 Forbidden**: 서버가 요청을 이해했지만 **승인을 거부**했음을 나타냅니다. 주로 인증 자격 증명은 있지만, 접근 권한이 부족한 경우 (인가(Authorization) 문제)에 발생합니다.
  - **404 Not Found**: 요청 리소스를 서버에서 **찾을 수 없음**을 나타냅니다. 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기기 위해 사용될 수도 있습니다.

- 5xx (Server Error)

  : 

  서버 문제로 오류가 발생

  했음을 나타냅니다.

  - 서버에 문제가 있기 때문에, **재시도하면 성공할 수도 있습니다** (서버 복구 등).
  - **500 Internal Server Error**: 서버 내부 문제로 오류 발생, **애매하면 500 오류**를 사용합니다.
  - **503 Service Unavailable**: 서버가 일시적인 과부하 또는 예정된 작업으로 인해 요청을 처리할 수 없음을 나타냅니다. `Retry-After` 헤더 필드로 언제 복구되는지 알려줄 수 있습니다.

## 6. HTTP 헤더

### 6.1. 일반 헤더 (General Headers)

- HTTP 헤더는 `field-name ":" OWS field-value OWS` 형식이며, 필드 이름은 대소문자를 구분하지 않습니다.

- **HTTP 전송에 필요한 모든 부가 정보**를 담습니다. (예: 메시지 바디 내용, 크기, 압축, 인증, 요청 클라이언트/서버 정보, 캐시 관리 정보 등).

- 과거 RFC2616에서는 General, Request, Response, Entity 헤더로 분류했지만, 2014년 RFC7230+에서는 'Entity' 개념이 **'표현(Representation)'**으로 변경되었습니다.

  - 메시지 바디를 통해 **표현 데이터(payload)**를 전달하며, **표현 헤더**는 표현 데이터를 해석할 수 있는 정보를 제공합니다. (예: 데이터 유형, 길이, 압축 정보 등).

- **Content-Type**: **표현 데이터의 형식**을 설명합니다 (미디어 타입, 문자 인코딩). (예: `text/html; charset=utf-8`, `application/json`, `image/png`).

- **Content-Encoding**: **표현 데이터를 압축하기 위해 사용**됩니다. (예: `gzip`, `deflate`, `identity`). 데이터를 전달하는 곳에서 압축 후 인코딩 헤더를 추가하고, 읽는 쪽에서 헤더 정보로 압축을 해제합니다.

- **Content-Language**: **표현 데이터의 자연 언어**를 표현합니다. (예: `ko`, `en`, `en-US`).

- **Content-Length**: **표현 데이터의 길이(바이트 단위)**를 나타냅니다. `Transfer-Encoding`을 사용하는 경우에는 `Content-Length`를 사용하면 안 됩니다.

- 협상 (콘텐츠 네고시에이션)

  : 클라이언트가 선호하는 표현을 요청하는 기능입니다. 협상 헤더는 요청 시에만 사용됩니다.

  - **`Accept`**: 클라이언트가 선호하는 미디어 타입을 전달합니다.
  - **`Accept-Charset`**: 클라이언트가 선호하는 문자 인코딩을 전달합니다.
  - **`Accept-Encoding`**: 클라이언트가 선호하는 압축 인코딩을 전달합니다.
  - **`Accept-Language`**: 클라이언트가 선호하는 자연 언어를 전달합니다.
  - **Quality Values (q)**: 0~1 사이의 값을 사용하여 우선순위를 나타냅니다. 클수록 높은 우선순위이며, 생략 시 1로 간주됩니다. 구체적인 것이 더 높은 우선순위를 가집니다.

- 전송 방식

  :

  - **단순 전송**: `Content-Length`를 사용하여 데이터를 한 번에 전송합니다.
  - **압축 전송**: `Content-Encoding`을 사용하여 데이터를 압축하여 전송합니다.
  - **분할 전송**: `Transfer-Encoding: chunked` 헤더를 사용하여 데이터를 청크(chunk) 단위로 분할하여 전송합니다. `Content-Length`를 알 필요가 없습니다.
  - **범위 전송**: `Range` 요청 헤더와 `Content-Range` 응답 헤더를 사용하여 데이터의 특정 범위(부분)만 요청하고 응답할 수 있습니다.

### 6.2. 특별한 정보 헤더

- **From**: 유저 에이전트의 이메일 정보지만, 일반적으로 잘 사용되지 않습니다.
- **Referer**: 현재 요청된 페이지의 이전 웹 페이지 주소를 나타냅니다. 유입 경로 분석에 활용될 수 있습니다. (참고: 단어 `referrer`의 오타).
- **User-Agent**: 클라이언트의 애플리케이션 정보(웹 브라우저 정보 등)를 나타냅니다. 통계 분석이나 장애 파악에 활용될 수 있습니다.
- **Server**: 요청을 처리하는 오리진 서버의 소프트웨어 정보를 나타냅니다 (예: Apache, nginx).
- **Date**: 메시지가 생성된 날짜와 시간을 나타냅니다.
- **Host**: **요청한 호스트 정보(도메인)**를 나타냅니다. **필수 헤더**이며, 하나의 IP 주소에 여러 도메인이 적용되어 하나의 서버가 여러 도메인을 처리해야 할 때 사용됩니다.
- **Location**: 페이지 리다이렉션을 위한 URI를 나타냅니다. `201 Created` 응답 시 생성된 리소스의 URI를, `3xx Redirection` 응답 시 자동으로 리다이렉트할 대상 리소스를 가리킵니다.
- **Allow**: 대상 리소스가 허용하는 HTTP 메서드 목록을 나타냅니다. `405 Method Not Allowed` 응답에 포함되어야 합니다.
- **Retry-After**: 사용자 에이전트가 다음 요청을 하기까지 기다려야 하는 시간을 나타냅니다. `503 Service Unavailable` 응답과 함께 서버가 언제까지 불능인지 알려줄 수 있습니다.

### 6.3. 인증 (Authentication) 헤더

- **Authorization**: 클라이언트의 인증 정보를 서버에 전달합니다 (예: `Basic xxxxxxxxxxxxxxxx`).
- **WWW-Authenticate**: 리소스 접근 시 필요한 인증 방법을 정의합니다. `401 Unauthorized` 응답과 함께 사용됩니다.

### 6.4. 쿠키 (Cookie)

- HTTP는 기본적으로 **무상태(Stateless) 프로토콜**이므로, 클라이언트와 서버는 요청과 응답 후 연결이 끊어지면 이전 요청을 기억하지 못합니다. 이를 보완하기 위해 쿠키가 사용됩니다.

- **`Set-Cookie`**: **서버에서 클라이언트로 쿠키를 전달**하는 응답 헤더입니다.

- **`Cookie`**: **클라이언트가 서버로부터 받은 쿠키를 저장하고 있다가, HTTP 요청 시 서버로 다시 전달**하는 요청 헤더입니다.

- 사용처

  :

  - **사용자 로그인 세션 관리**에 주로 사용됩니다. (예: 로그인 시 서버가 `sessionId` 쿠키를 발행하고, 이후 요청 시 브라우저가 이 쿠키를 자동으로 포함하여 서버로 보내 로그인 상태 유지).
  - 광고 정보 트래킹 등에도 사용됩니다.

- 특징 및 주의사항

  :

  - 쿠키 정보는 **항상 서버에 전송**되므로 네트워크 트래픽이 추가로 발생합니다. 따라서 최소한의 정보(예: 세션 ID, 인증 토큰)만 사용해야 합니다.
  - **보안에 민감한 데이터(예: 주민번호, 신용카드 번호)는 쿠키에 저장하면 안 됩니다**.
  - 서버에 전송하지 않고 브라우저 내부에 데이터를 저장하고 싶다면 웹 스토리지(`localStorage`, `sessionStorage`)를 고려할 수 있습니다.

- 생명주기 (Expires, max-age)

  :

  - `Set-Cookie: expires=Sat, 26-Dec-2020 00:00:00 GMT`: 만료일을 지정하며, 해당 날짜가 되면 쿠키가 삭제됩니다 (영속 쿠키).
  - `Set-Cookie: max-age=3600`: 쿠키의 유효 시간을 초 단위로 지정합니다. 0이나 음수 지정 시 쿠키가 삭제됩니다.
  - 만료 날짜를 생략하면 브라우저 종료 시까지만 유지되는 **세션 쿠키**가 됩니다.

- 도메인 (Domain)

  :

  - `domain=example.org`와 같이 명시하면, 명시된 도메인과 그 서브 도메인(예: `dev.example.org`) 모두 쿠키에 접근할 수 있습니다.
  - 도메인 지정을 생략하면, 현재 문서의 도메인(예: `example.org`)에서만 쿠키에 접근할 수 있고, 서브 도메인에서는 접근할 수 없습니다.

- 경로 (Path)

  :

  - `path=/home`과 같이 지정하면, 해당 경로를 포함한 하위 경로의 페이지만 쿠키에 접근할 수 있습니다.
  - 일반적으로 `path=/`(루트)로 지정하여 모든 경로에서 쿠키에 접근할 수 있도록 합니다.

- 보안 (Secure, HttpOnly, SameSite)

  :

  - **`Secure`**: `https`인 경우에만 쿠키를 전송합니다. `http`와 `https`를 구분하지 않고 전송되는 쿠키의 보안 취약점을 보완합니다.
  - **`HttpOnly`**: **XSS(Cross-Site Scripting) 공격 방지**에 사용됩니다. 자바스크립트에서 쿠키에 접근하는 것을 막고, HTTP 전송에만 사용하도록 합니다 (`document.cookie` 접근 불가).
  - **`SameSite`**: **XSRF(Cross-Site Request Forgery) 공격 방지**에 사용됩니다. 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송하도록 합니다.

## 7. 캐시와 조건부 요청

### 7.1. 캐시 기본 동작

- **캐시가 없을 때**: 데이터가 변경되지 않아도 매번 네트워크를 통해 전체 데이터를 다시 다운로드해야 합니다. 이는 인터넷 네트워크의 느리고 비싼 특성 때문에 브라우저 로딩 속도를 느리게 하고 사용자 경험을 저하시킵니다.

- 캐시 적용

  :

  - 서버 응답에 `Cache-Control: max-age=60`과 같은 캐시 제어 헤더를 추가하여, 브라우저 캐시에 해당 데이터를 일정 시간(예: 60초) 동안 저장하도록 지시합니다.
  - 캐시 유효 시간 동안은 네트워크를 사용하지 않고 브라우저 캐시에서 데이터를 조회합니다.
  - 이는 **네트워크 사용량을 줄이고, 브라우저 로딩 속도를 매우 빠르게 하여 사용자 경험을 향상**시킵니다.

- **캐시 시간 초과**: 캐시 유효 시간이 초과하면, 브라우저는 서버를 통해 데이터를 다시 조회하고 캐시를 갱신합니다. 이 과정에서 다시 네트워크 다운로드가 발생할 수 있습니다.

### 7.2. 검증 헤더와 조건부 요청

- **목적**: 캐시 유효 시간이 초과했더라도, **서버의 데이터가 갱신되지 않았다면 전체 데이터를 다시 다운로드하지 않고 저장해 두었던 캐시를 재사용**할 수 있도록 하는 매우 실용적인 해결책입니다. 이를 위해서는 클라이언트의 데이터와 서버의 데이터가 동일하다는 것을 확인할 방법이 필요합니다.

- 검증 헤더 (Validator)

  : 캐시 데이터와 서버 데이터가 같은지 검증하는 데 사용되는 헤더입니다.

  - `Last-Modified`

    : 데이터가 마지막으로 수정된 시간을 나타냅니다 (예: 

    ```
    2020년 11월 10일 10:00:00
    ```

    ).

    - **단점**: 1초 미만 단위로 캐시 조정이 불가능하고, 데이터를 수정해서 날짜는 다르지만 실제 데이터 결과는 똑같은 경우(예: 주석 변경)에도 캐시가 갱신될 수 있습니다. 서버에서 별도의 캐시 로직을 관리하고 싶은 경우(예: 스페이스 변경에도 캐시 유지)에도 문제가 될 수 있습니다.

  - `ETag` (Entity Tag)

    : 캐시용 데이터에 임의의 

    고유한 버전 이름

    을 달아둡니다 (예: 

    ```
    "v1.0"
    ```

    , 

    ```
    "aaaaaaaaaa"
    ```

    ). 데이터가 변경되면 이 이름(해시 값)을 바꾸어 변경을 알립니다 (예: 

    ```
    "aaaaa"
    ```

     -> 

    ```
    "bbbbb"
    ```

    ).

    - **`ETag`의 장점**: `Last-Modified`의 단점을 해결하며, **캐시 제어 로직을 서버에서 완전히 관리**할 수 있게 합니다. 클라이언트는 단순히 이 값을 서버에 제공하여 같으면 캐시를 유지하고, 다르면 다시 받습니다.

- 조건부 요청 헤더

  : 검증 헤더의 값으로 조건에 따른 분기 처리를 수행합니다.

  - **`If-Modified-Since`**: `Last-Modified` 값과 함께 사용됩니다. "이 시간 이후에 데이터가 수정되었으면?"이라는 조건을 서버에 보냅니다.
  - **`If-None-Match`**: `ETag` 값과 함께 사용됩니다. "이 ETag와 다르면?"이라는 조건을 서버에 보냅니다.

- 검증 결과에 따른 응답

  :

  - **조건 만족 (서버 데이터가 갱신되지 않았을 때)**: 서버는 **`304 Not Modified`** 응답과 함께 헤더 메타 정보만 보냅니다 (바디 없음). 클라이언트는 이 응답 헤더 정보로 캐시의 메타 정보를 갱신하고, 캐시에 저장된 기존 데이터를 재활용합니다. 결과적으로 **네트워크 다운로드 용량이 적은 헤더 정보만 전송**됩니다.
  - **조건 불만족 (서버 데이터가 변경되었을 때)**: 서버는 **`200 OK`** 응답과 함께 모든 데이터(헤더 + 바디)를 전송합니다.

### 7.3. 캐시 제어 헤더

- `Cache-Control`

  : 캐시 지시어(directives)를 포함합니다.

  - `max-age`: 캐시 유효 시간을 초 단위로 지정합니다.
  - `no-cache`: 데이터는 캐시해도 되지만, **항상 원(Origin) 서버에 검증하고 사용**해야 합니다 (이름에 주의).
  - `no-store`: 데이터에 민감한 정보가 있으므로 **저장하면 안 됩니다** (메모리에서 사용하고 최대한 빨리 삭제).
  - `public`: 응답이 public 캐시(프록시 캐시)에 저장되어도 됨을 나타냅니다.
  - `private`: 응답이 해당 사용자만을 위한 것이므로 private 캐시(브라우저 캐시)에 저장해야 함을 나타냅니다 (기본값).
  - `s-maxage`: 프록시 캐시에만 적용되는 `max-age`입니다.
  - `must-revalidate`: 캐시 만료 후 최초 조회 시 원 서버에 반드시 검증해야 합니다. 원 서버 접근 실패 시 **반드시 오류가 발생(504 Gateway Timeout)해야 합니다**. 캐시 유효 시간 내에서는 캐시를 사용합니다.

- **`Pragma`**: `no-cache`와 같은 캐시 제어 기능을 제공하며, **HTTP 1.0 하위 호환**을 위해 사용됩니다.

- **`Expires`**: 캐시 만료일을 정확한 날짜로 지정합니다. **HTTP 1.0부터 사용되었으며, 현재는 더 유연한 `Cache-Control: max-age`를 권장**합니다. `Cache-Control: max-age`와 함께 사용될 경우 `Expires`는 무시됩니다.

### 7.4. 프록시 캐시

- 클라이언트와 원 서버 사이에 위치하여 캐시 기능을 수행하는 서버입니다.
- 클라이언트가 프록시 캐시 서버를 통해 데이터를 받으면, 네트워크 지연을 줄이고 전체 네트워크 사용량을 효율적으로 관리할 수 있습니다.
- **`Age`**: 응답이 오리진 서버에서 생성된 후 프록시 캐시 내에 머문 시간(초)을 나타내는 HTTP 헤더입니다.

### 7.5. 캐시 무효화

- 확실한 캐시 무효화 응답을 위해서는 다음과 같은 헤더를 함께 사용합니다:
  - **`Cache-Control: no-cache, no-store, must-revalidate`**.
  - **`Pragma: no-cache`** (HTTP 1.0 하위 호환).